## 考察
- 過去に解いたことあり
- 方針
    - 繰り上がりを保持しながら、対応するノードを一つずつ足していけばよさそう(頭の中では筆算を連想)
        - time: O(n), space: O(n)
    - 繰り上がりが最後に残った場合のみ注意
- リストの走査は繰り返しでも再帰でもOK
    - 再帰にするメリットは思いつかないので繰り返しでいく
- あとは実装

## Step1
- 上で考えたアルゴリズムを実装
- 1つ気になるのがメモリ管理のところ
    - 新しいノードをスタック領域に確保するとスコープを抜けた時点でメモリが解放されるのでうまくいかない
    - ヒープ領域にオブジェクトを作成したけど、このオブジェクトの管理は誰の責務になるのかがわかっていない
    - C++実務で使ったことないが、実務だとどうやるんだろう
        - Linked Listのポインタをスマートポインタにすればよさそう？ -> 参照が切れた時点で自動的にメモリが解放されそう

## Step2
- メモリ管理について他の人のPRをいくつか検索してみた
    - LeetCode上の制限という問題もありそう。ただ問題意識は常に持っていたい。
    - Ref. https://github.com/Ryotaro25/leetcode_first60/pull/5#discussion_r1611301775
- 最後にcarryをチェックして、1を追加していたところをメインロジックに吸収できたので修正した

## Step3
- 1回目: 2m00s
- 2回目: 1m58s
- 3回目: 1m33s

