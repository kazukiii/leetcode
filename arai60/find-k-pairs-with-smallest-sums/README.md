## 考察
- 初見の問題
- 方針を考える
    - ソートする
        - time: O(n^2 log n), space: O(n^2)
        - n <= 10^5 なので、計算ステップ数は最悪10^10オーダー -> ✕
        - メモリも例えばintを10^10持つことを考えると、4 * 10^10 bytes = 40GB -> ✕
    - サイズkの最大ヒープを使う
        - time: O(n^2 log k), space: O(k)
        - spaceは大丈夫そうだが、timeがきつそう -> ✕
    - 最小ヒープを使う
        - 各配列がソートされているのをうまく使いたい
        - sumが要素の行列を考えて、行列の各行にnums1の要素を対応させると、行がソート済みの行列が見える
        - この構造は何度か見たことがある
        - merge k sorted lists の要領で小さいものから順番に取り出していけそう
            - Ref. https://leetcode.com/problems/merge-k-sorted-lists/description/
        - メモリ上、あらかじめ全てのsumを計算しておくことができないので、その都度計算するように工夫する必要がありそう
        - time: O(n log n + k log n), space: O(n)
        - たぶんいける
- 最小ヒープを使う方針でやってみる
- あとは実装

## Step1
- 上記のアルゴリズムを実装
- time: O(n log n + k log n), space: O(n)
- パスはしたけど、かなり遅い(Runtime beats 5.05%)

## Step2
- Solutionsを覗いてみた
- サイズkの最大ヒープを使う O(n^2 * log k) のアルゴリズムを適切に枝狩りすることでもっと速度を出せるみたい
- この方針でもやってみる
- 実装してみて、結構自然な考え方かもしれないが、計算量評価が難しく感じた

## Step3
- Step1のアルゴリズムの方がしっくり来たため、そちらで実装した
- 1回目: 9m16s
- 2回目: 8m57s
- 3回目: 8m52s

## Step4
- 行列が縦方向にもソートされていたことに気づいたので、ロジックを少し修正
    - nums1.size() > kのとき、上からk行だけ考えればよかった
    - k + 1行目より先に必ず上のk個が選ばれるため
- レビューを元に修正
- 変数名の変更
    - pair -> elements (pairはstdの予約語のため)
- SumPairのelementsとindiceは要素数が必ず2つなので型を変更
    - vector<int> -> pair<int, int>
- SumPairにコンストラクタを定義して、同じ記述を集約
- emplace_backやemplaceを使うことでコンストラクタの引数を直接受け取り、コンテナの末尾に新しい要素を直接構築できる
- moveすることで構造体のコピーを防ぎ、所有権だけ移動できる
- answerは要素数がkであることが確定しているので、先にメモリをreserveしておく
