## 考察
- 過去に何度も解いたことあり
- 方針は4つ思い浮かぶ
    - 全探索
        - C(n, 2)パターンを全部調べる
        - 今回はこの方針はスキップ
        - time: O(n^2), space: O(1)
    - ハッシュマップ
        - 追加のメモリを使用する
        - 足し算が可換(答えの順番が関係ない)ので1パスでOK
        - 引き算とかだとおそらく1パスではできない
        - time: O(n), space: O(n)
    - ソートして二分探索
        - ソートしたら二分探索可能
        - time: O(n log n), space: O(1)
    - ソートして2 pointers
        - メモリO(1)の解法では、最速になると思う
        - ソートがボトルネックになる
        - time: O(n lon n), space: O(1)
- ハッシュマップを使った手法を選択
- あとは実装

## Step1
- ハッシュマップを使った方法を実装
- time: O(n), space: O(n)

## Step2
- 2 pointersの手法でもやってみる
- ソートするとインデックスが変わるのでそこだけ注意した
- time: O(n log n), space: O(1)

## Step3
- ハッシュマップを使った方法で実装
- 1回目: 1m02s
- 2回目: 55s
- 3回目: 47s
