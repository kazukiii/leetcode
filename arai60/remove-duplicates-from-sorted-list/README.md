## 考察
- 初見の問題
- ソート済みとあるので、同じvalを持ったノードは隣接する
- 直前の値を覚えておいて、現在の値が直前と同じだったらスキップしていけば良さそう
- return用のリストを新しく生成すると、空間計算量がO(n)となるので、うまくポインタを繋ぎ変えてO(1)で実現したいところ
- (メタ的な思考になってしまうが、新しいリストを生成するだと、問題がLinked Listである意味がなくなってしまう)
- スキップする = 次の次のノードに繋げてしまえばよさそう
- リストの走査方法は、再帰でも出来るが、前回同様繰り返し処理でいく
- あとは実装

## Step1
- 上のアルゴリズムを実装した
- ダミーヘッドを `ListNode* dummy = new ListNode();` としてしまいWA
- `-100 <= Node.val <= 100` なので、範囲外の値を使わないといけなかった
- time: O(n), space: O(1)

## Step2
- よく考えるとダミーヘッドを用意する必要なかったので、余計な処理を削除した

## Step3
- 1回目: 1m03s
- 2回目: 50s
- 3回目: 53s
